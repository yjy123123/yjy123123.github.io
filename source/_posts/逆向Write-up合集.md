---
title: 逆向Write up合集
date: 2021-03-06 15:06:06
tags: 逆向
description: CTF逆向题练手合集，之后可能会更多的总结知识点，持续更新。
---
## XCTF攻防世界

### open_source

这道题直接给了源码，读就行了，一开始以为文件名是32位hash，但是计算的话太大，也无法解密，所以突破口还是hash本身的计算，从之前的判断可以推出，其实(second % 17)就是等于8。

算出来还要转为16进制。


### logmein

也是考的阅读c的能力，拖到ida里面F5反编译，简单读一下，突破口应该在判断语句里面。

![](reverse-1.png)

处理之后提示数太大了，乍看一眼*(_BYTE *)不太理解什么意思，但是感觉long整数和字符串长度差不多，可以合理推测，可能需要对long型的数据一个字节一个字节的处理。

结果是我看错了，括号其实对应错了，(*((_BYTE *)&v7 + i % v6)，(_BYTE *)&v7是一个整体，实现的功能也是从long中依次取一个字节的数。

首先要知道long在机器中是如何存储的，才知道怎么取出，在汇编中，一般是小端存储，所以按地址取数是从低位开始往高位取，一个字节可以存储两个16进制数，所以一次取两个数，这也解释i % 7 的原因。

最开始想用模运算取数，还停留在10进制中，但是python实现16进制模运算有一个坑就是，会把%识别成格式化的符号，所以这了采用```x>>(8^i)&0xFF```来取数据。

最后16进制结果要转为ascii码。

这道题花了一点时间，我用python处理进制的转换非常的不熟悉，真的头大。

[这篇文章](https://reverseengineering.stackexchange.com/questions/13703/what-is-byte-usercall-eax-and-edi)中对*(_BYTE *)的解释：

```
This actually has two distinctive parts, evaluated one after the other.

First, (_BYTE *) casts a value or a register to be a byte pointer. This is similar to assigning the value to a C variable which is defined as byte *.

Second, * dereferences the address and retrieves the value in that address, value is assumed to be of the type of the pointer, in our case _BYTE.
```

拆解出来就是先将值转换为字节指针，之后再找地址对应值。

---
我觉得自己的解法太麻烦了，最后看了一下其他人的，有的v7反汇编出来就是一个字符串而不是long型，但是这个估计一开始会想不到小端存储，把v7换成字符串处理确实方便很多。

### insanity

先用ida看了一下，反编译出来的结果很简单，看一看有没有什么有效的字符信息。直接看到一个像flag的东西，我开始只提交了字符，没加前面数字，还好再尝试提交了一次，不然又掉坑里面了。

### getit

ida反编译main函数，感觉核心内容是对"/tmp/flag.txt"文件的写入，fputc做的就是写入操作，另外关注s和t两个参数，从长度来看，感觉又是和logmein一样的套路，但是简单很多，也没什么大小端。

但是总是提交不对，我还以为第二步文件写入打乱顺序了写入，可能要动态调试因为太麻烦了准备看一下到底怎么回事，结果是ida里面字符串只显示了```harifCTF{}```，掉了一个S，ghidra里面可以正常显示出，我不知道为什么，我差点骂出世界上最脏的脏话。不过这道题确实可以动态分析跑出来，更快一点。

### python-trade

这一道题是python反编译，```pip install uncompyle```，用uncompyle反编译出来直接是python代码了。

这里有一个点就是，base64解码出来的结果是bytes。

### re1

反编译之后看到strcmp，v9和v5，v5是用户输入，突破口就是v9了，顺着找过去是一串16进制数，分成了两段，直接16进制转ascii码看一下，是一串像flag的东西，但是顺序是反的，从程序逻辑来看就是flag，不知道考点是啥。

而且这道题在macos下会乱码。

### game

这道题感觉程序比较大，简单用ida看了一下，感觉没什么有效信息，所以还是运行玩一玩游戏，感觉这道题可能用动态分析工具比较好，现在是考虑修改内存把灯全部点亮。

### 小总结

做了好几道题，简单题基本上还是读C，要熟悉16进制的各种操作，而且本质就是通过加密算法写对应的解密算法。



### simple-unpack

给了提示是脱壳相关的，之前电脑里面下了upx，查了一下指令，upx -d 直接脱壳，感觉我 -h不太会看，应该要学一学。



### Hello, CTF

这道题，F5反编译之后直接阅读代码，很好理解，就是输入和字符串“437261636b4d654a757374466f7246756e”比较，但是输入字符串长度应该为17，被比较的字符串长度为35，我当时就像，啊，这是溢出吗，没什么想法，然后到处看了看，无意间回到题目描述

> 菜鸡发现Flag似乎并不一定是明文比较的



然后我悟了，16进制转ascii，flag就出来了，怎么说呢，一周多没做题了，感觉脑子就像生锈了一样，不太敏锐了，在思考如果没有题目描述，我解这道题要多久。

之前连做六七道题的时候，对有些套路还是有点感觉的，很快就能get到，到了这周，我就恨自己是块木头。



### no-strings-attached

这道题做的太自闭了，看了题目描述，说运行就可以拿flag，所以全心全意想着怎么运行起来，linux下的32位elf文件，好不容易安装32位的lib库，运行还报错，整个人都傻了。

```
sudo apt-get install lib32ncurses5
```

最后还是回归ida，结果就是一个普通套路的加解密，两个数组操作，浪费大量时间想把它跑起来的我深深叹了一口气。



### maze

一开始直接IDA静态分析，F5反编译之后，重点看了一下main函数，感觉有点不太对，因为直接靠用户输入进行规则判定，唯一有参考价值的字符串asc_601060看不出什么名堂，感觉静态分析不太可靠。难道是按规则穷举暴力破解吗？后面仔细观察if语句里面的判断条件，看了一下出现的十进制数对应的ascii码（其实是因为读了一半读吐了，为了避免入门到放弃另寻出路。

```
79 - O
111 - o
46 - .
48 - 0
35 - #
```


参考了一下IDA动态调试的[博客](https://blog.csdn.net/abc_670/article/details/80066817)

把几个判断跳转的地方，特别是跳转到label_22要退出的地方下了断点，试一试`nctf{000000000000000000}`，发现可以单步。弄了半天无发现，倒是某一篇博客里面提到，想要练手可以试一试xctf的track2，这就意味着，这道题应该不是动态调试。

又回到main函数，但是判断语句太多，括号什么的不好看，装了一个高亮括号的[hexlight插件](https://www.52pojie.cn/thread-727586-1-1.html)，但是感觉使用感一般。

之后就是分析-推翻-分析-推翻，搞到自闭的循环，最后回到题目描 述，菜鸡走出迷宫s m de，结合asc_601060，一共64位，那么弄成8*8矩阵看看什么情况，就真•迷宫呗，不过‘maze’这个词本身也有迷宫的意思，哎，这就是英语不好的代价吗。



```
··******
*···*··*
***·*·**
**··*·**
*··*#··*
**·***·*
**·····*
********
```

那么[**'0'**,**'o'**,**'O'**,**'.'**]也就是四个方向，走出迷宫的路径就是flag，开始在分析v9的时候（ida一开始显示成v10，类型是__int64），总是不知道到底是个什么，SHIDWORD之前也没见过，推测是不是计数器，但是知道是迷宫之后，猜测可能是二维数组。

查资料之后发现这个[issue](https://reverseengineering.stackexchange.com/questions/8296/whats-the-function-of-lodword-and-hidword)里面有详细解释，SHIDWORD其实就是取v9的高位，存储的是列，v9低位是行，这个从最后一句判断是不是找到出口了可以看出来。

```
 if ( asc_601060[8 * (signed int)v9 + SHIDWORD(v9)] != 35 )
```

那么再看和四个方向相关的函数，加法的就是👇，👉，减法的就是👇，👈；再看具体传入函数的参数，`(_DWORD *)&v9 + 1`和`(int *)&v9`，传入的是地址，+1也比较好理解，因为小端存储，高位放在高地址里面，那么显然`&v9 + 1`就是`SHIDWORD(v9)`。加上自减操作，所以O对应的就是左，以此类推。

```
O  o  . 0
左 右 上 下  
```

个人觉得这道题一如以上来就莽的话蛮搞心态的，但是如果结合题目和描述各方面信息+经验多对这些敏感的话就其实简单。断断续续做了好几天，差点就做不下去了。不过也发现自己指针什么的全部忘光了，只是还是要经常用才记得住。

