---
title: CS4.0木马逆向分析
date: 2021-05-28 16:19:52
tags: 恶意代码分析
description: 不过是老板的任务罢了，第一次分析恶意代码，差点整吐了。
---

这个是一个课程作业，但是我真的搞了可久了，重新整理记录一下。分析的恶意样本就是CS工具生成的64位EXE文件，生成过程这里就不赘述了。目前现有的分析CS木马的博客还是挺多的。

先用了奇安信的在线沙箱看了一下具体功能。

![](1.png)

![](2.png)

没有文件操作，没有注册表操作，但是和服务器进行了通信。

### 静态分析

![](3.png)

首先分析了一下`main`函数，`main`函数中包含`sub_402A20`和`sub_401755`两个函数，然后进行一个休眠10s的循环中。

![](4.png)

`sub_401755`函数中包含该程序的一些主要功能。`GetTickCount`返回的是从操作系统启动到现在所经过的毫秒数，这里`GetTickCount`模了0x26AA，这一步的操作是为了获取一个随机数，用于后续字符串的拼接。

这里的sprintf是对字符串`MSSE-%d-server`进行一个拼接，`MSSE-%d-server`是Cobalt Strike的一个很明显特征。

因为反编译的代码里面每个参数不是很清晰，所以这里从汇编代码看一下拼接的结果。

![](5.png)

一开始就是对`GetTickCount`的一个除法，结果存放在EAX中，再往后看的话，有一个`mov [rsp+68h+var_10], edx`的操作，是把`GetTickCount`取模的结果放入了栈中。

这里是用了`sprintf`函数，关于函数参数传参，在Windows X64中，函数参数的前四个参数是从左至右依次存放于RCX、RDX、R8、R9寄存器里面，剩下的参数从右至左顺序入栈；栈的增长方向为从高地址到低地址。

在回到汇编代码，首先RCX中传入`SecurityAttributes`，RDX中为`aCCCCCCCCCmsseD`,即`%c%c%c%c%c%c%c%c%cMSSE-%d-server`，r8d即r8寄存器的低32位存放`\`,r9d中也是`\`，剩下的参数是从右至左入栈，依次是`GetTickCount%0x24aa\epip\.`，那么从右往左是`.\pipe\ GetTickCount%0x24aa`。

`Sprintf`函数是用来拼接字符串的，那么结合传参的顺序来看，整个的结果就是`\\.\pipe\MSSE-v2-server`， 存放在`SecurityAttributes`里面，就是管道名称，是一个全局变量。

之后是创建线程，继续跟进查看。

![](6.png)

`sub_401645`函数里面继续调用了一个`sub_401590`函数，`unk_404010`是一连串不可读的字符，目前不太清楚具体功能，只能看看`sub_401590`的内容。

![](7.png)

`sub_401590`中函数还是比较多的，看了一下调用函数的名称，应该就是核心功能实现的地方了。首先是`CreateNamedPipeA`函数，用来创建一个命名管道；`ConnectNamedPipe`函数用于等待客户端连接命名管道；`WriteFile`用于写文件；`CloseHandle`用于关闭线程。

那么可以合理假设该函数的整个功能是先创建一个命名管道，然后等待连接，`WriteFile`函数就是用于向管道中写入命令。

![](8.png)

查看汇编代码，看具体创建管道的过程，和反编译出来的结果差不多，但是多了很多标识，创建管道的话应该需要指定管道名称，这里推测`SecurityAttributes`应该就是之前拼接而成的管道名称。

文件的写入应该是一个循环写入，v5>0就是判断条件，应该是字符长度，看v5参数传递过程，就是函数传入的第三个参数a3，即`dword_404004`，大小是0x3FA00，写入内容就是从`unk_404010`开始的字符，这些字符都是不可读的，应该经过了加密。这里没有看的太详细，直接推测0x3FA00时shellcode大小，`unk_404010`开始就是加密后的shellcode，后续再求证。

![](9.png)

完成文件的写之后，再回到创建线程的函数`sub_401755`中，该函数最后返回的是`sub_401702`函数。该函数先malloc了一个内存，之后进入休眠，休眠1024ms，然后进入`sub_401662`函数，这个地方是循环执行Sleep、`sub_401662`函数，基本逻辑就是监听管道，如果创建成功，就进行连接。

![](10.png)

接下来关注`sub_401662`函数，里面是创建文件和读取文件的操作。这里用`CreateFileA`打开管道，这里都比较直观，之后的`ReadFile`又是一个循环读文件的操作。这里就是把先前的shellcode从管道里面读出来。	

![](11.png)

当函数完成管道内容的读之后，调用`sub_4014F3`函数，改函数主要完成两个功能，一个是异或解密，一个是创建新线程。

![](12.png)

具体看异或的过程，反编译出来的代码也很直接，原始需要解密的内容shellcode和一个解密数组异或，就得到解密后的shellcode，这里通过模3来看，解密数组的长度应该为3，这个地方没办法定位到具体的解密数组，没有其他信息，但是之前在分析的时候，在`dword_404004`和`unk_404010`中间有一个很短的数组`unk_404008`，`unk_404008`的前三个字节应该就是用来解密的字节。

![](13.png)

之后一步一步返回到main函数，下一步是想通过动态调试来dump解密的shellcode。



### 动态调试

这里使用x64dbg来对程序进行分析。这里先在`sub_401755`里面拼接字符串的地方下了断点，想核对一下拼接结果（其实是想截图糊报告），可以看到和静态分析中一样，`GetTickCount`获取系统时间之后，随机数计算结果为5505，拼接管道名为`\\.\pipe\MSSE-5505-server`，不过x64dbg显示的时候对\进行了转义。

![](14.png)

之后关注异或解密的地方，因为想通过动态调试dump解密后的shellcode。解密函数辨识度还是挺高的，就是异或操作。

![](15.png)

在异或解密的地方看了几轮，关注用于异或解密的数组，长度应该为4，[‘5D’,’CC’,’E1’,’31’]，是之前提到的`unk_404008`的前四位。

但是之前反编译结果是模3，我就很迷，仔细看一下汇编代码，并没有shr或者idiv、div一类的指令，也不太像编译器优化后的结果。

![](16.png)

这里想要获取解密后的Shellcode，把它dump出来，首先在`VirtualProtect`的地方下断点(这个思路是参考了一篇博客)，这里结合ida反编译的代码来看，v9是`VirtualAlloc`出来的一片内存空间，用来存放解密后的shellcode，`VirtualProtect`中的v9是第四个参数，对应的是rbx寄存器。

![](17.png)

运行到`VirtualProtect`之后，查看rbx，对应地址是190000，点击右键->在内存窗口中转到，就可以看见解密出来的结果了，开头就是4D5A，典型的PE文件，大小是以前静态分析的时候看到的`dword_404004`，大小为3FA00h，直接把从0x190000到0x1CFA00的内容dump出来另存为shellcode.bin文件，这个文件中就是Cobalt Strike实现主要功能的部分。

![](18.png)

后续对shellcode.bin文件进行分析，这个文件比较大256k，先用PEID看一下文件信息。是一个64位的PE文件，同时关注了一下文件的导入表，wininet主要是windows中网络相关模块dll文件，这里就应该是网络通信相关的一些协议。除此之外，kennel32里面也有一些文件操作相关的函数。



### Shellcode分析

使用ida静态分析，发现整个程序比较大，函数也比较多，先看一下DLLMain函数，发现里面有一个`fdwReason`参数，只有`fdwReason`为4的时候，会进行一些恶意操作。

![](19.png)

因为函数非常多，不太好直接分析，所以选择从`InternetOpenA`函数入手，该函数是调用WinINet的第一个函数。查看一下函数的引用，在`sub_18000D858`中被调用。

![](20.png)

查看一下反编译的`sub_18000D858`函数，通过传入的参数名称和函数内部调用的一些函数都可以发现，该函数就是进行网络连接的函数。

![](21.png)

再一层一层向外跳，看一看该函数的调用具体情况。调用逻辑如下：

`DLLMain->sub_18000CA74-> sub_18000D858`

这里还用了一个修复DLL文件的插件，[下载地址](https://github.com/WBGlIl/ReflectiveDLL_Patch)

想通过动态调试看看连接到服务器的过程（没错依旧是为了截图糊报告），但是调着调着调不动了，报告DDL也要到了，我真的不太会动态调试，虽然很久没做题了，我真的会找几个题目练练手的我保证。

还有感谢教我动态调试的同学，估计被我气的够呛，然后友链也没做出来，下个月一定弄上。



### 参考博客

[1]https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/

这是一篇国外的分析CS的DLL Stager的博客，比较详细，原理细节都讲的很清楚，而且代码反汇编结果和我的样本反汇编结果很像，可惜没有shellcode的分析。

[2]https://bbs.pediy.com/thread-264470.htm

看雪上面的一篇分析博客，很详细，还有shellcode的调试过程，但是我跟着调硬是不太一样。

[3]https://mp.weixin.qq.com/s/iTzZGKkXK48NR8YT1OTw_Q

这一篇后面的特征分析写的很有参考价值。

[4]https://blog.csdn.net/JiangBuLiu/article/details/107788203

动态调试就是参考的这一篇，里面在VirtualProtect下断点的思路就是从这篇看的。

[5]https://blog.csdn.net/LoopherBear/article/details/106230996

这一篇主要是分析shellcode部分，因为我没怎么分析后面就没细看。

[6]https://www.anquanke.com/post/id/237127

印象有点模糊了。

所以，我是，为什么，看了，这么多，博客，还，分析了，那么，久......



